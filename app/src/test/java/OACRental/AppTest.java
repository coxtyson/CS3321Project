/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package OACRental;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import java.util.ArrayList;
import java.time.LocalDate;
import java.time.LocalDateTime;

public class AppTest {
    
    /*Test local Customer creation and basic accessor methods*/
    @Test
    public void testCustomerLocal()
    {
        /*Testing primary Customer constructor and accessor methods*/
        Customer testCustomer = new Customer("Test", "Customer", "00000", "123-456-7890", "Test@Test.com");
        assertNotNull(testCustomer, "Customer object must be created");
        assertEquals("Test", testCustomer.getFirstName(), "Customer must have first name");
        assertEquals("Customer", testCustomer.getLastName(), "Customer must have last name");
        assertEquals("Test Customer", testCustomer.getFullName(), "Customer full name must be accessible");
        assertEquals("00000", testCustomer.getID(), "Customer must have ID");
        assertEquals("123-456-7890", testCustomer.getPhone(), "Customer phone number must be accessible");
        assertEquals("Test@Test.com", testCustomer.getEmail(), "Customer email address must be accessible");

        Customer C2 = new Customer("Test", "Customer", "00001", "123-456-7899", "Test@test.com");
        assertFalse(C2.equals(testCustomer), "Test Customer and C2 are not the same");
        assertTrue(C2.equals(C2), "C2 and C2 are the same");

        C2.setEmail("Test@Test.com");
        C2.setID("00000");
        C2.setPhone("123-456-7890");
        assertTrue(C2.equals(testCustomer));


    }

    /*Tests price creation and accessor methods*/
    @Test
    public void testPrice()
    {
        /*Testing base constructor using 2 ints (dollars, cents)*/
        Price testPrice = new Price(11, 11);
        assertNotNull(testPrice);
        assertEquals(testPrice.cents, 11, 0, "Price must have cents");
        assertEquals(testPrice.dollars, 11, 0, "Price must have dollars");
        assertEquals(testPrice.getCents(), 11, 0, "Cents must be accessible");
        assertEquals(testPrice.getDollars(), 11, 0, "Dollars must be accessible");
        assertEquals(testPrice.getTotal(), 11.11, 0.0, "Price must be accessible as a double");

        Price testZero = new Price();
        assertNotNull(testZero);
        assertEquals(testZero.getTotal(), 0.0, 0.0);

        /*Testing the add function and single digit cent value constructor*/
        Price testAddOne = new Price(1,1);
        assertEquals(testAddOne.getCents(), 1, 0, "1.01 should only have 1 cent");
        assertEquals(1.01, testAddOne.getTotal(), "1.01 should have total of 1.01");

        testAddOne.add(testAddOne);
        assertEquals(2.02, testAddOne.getTotal(), "1.01 + 1.01 should be 2.02");


        Price testPriceDouble = new Price(2.99);
        assertEquals(testPriceDouble.getTotal(), 2.99, 0, "Double price constructor is working");

        /*Testing int constructor with a cent value > 99*/
        Price testCentRollover = new Price(10,105);
        assertEquals(testCentRollover.getDollars(), 11, 0, "105 cents should be converted to $1.05");
        assertEquals(testCentRollover.getCents(), 5, 0, "105 cents should be converted to $1.05");

        /*Testing double constructor with a cent value that has more than 2 digits of decimal values*/
        Price testCentRounding1 = new Price(11.115);
        Price testCentRounding2 = new Price(11.1109);
        assertEquals(11.12, testCentRounding1.getTotal(), 0, "$11.115 should be rounded to $11.12");
        assertEquals(11.12, testCentRounding2.getTotal(), 0, "$11.1109 should be rounded to $11.12");

        /*Testing multiply function*/
        Price testMultiplyDiscount = new Price(20.00);
        testMultiplyDiscount.multiply(0.5);
        assertEquals(10.00, testMultiplyDiscount.getTotal(), "20.00 * 0.5 should be 10.00");

        /*Testing toString function*/
        Price p = new Price(17.5);
        p.multiply(.06);
        assertEquals(1.05, p.getTotal(), 0, "17.5 * .06 = 1.05");
        assertEquals("$1.05", p.toString(), "Price(1.05) should display as string of '$1.05'");

    }

    /*Tests Product creation and accessor methods*/
    @Test
    public void testProduct()
    {
        //String name, String size, int quantity, Price price, boolean bundleOnly, boolean isActive
        Price price = new Price(11.11);

        Product testProduct1 = new Product("Test","Small", 10, price, false, false);
        Product testProduct2 = new Product("Test2", 5, price, true, false);
        Product testProduct3 = new Product("TestBundle", "Item1,Item2,Item3", price, true);

        assertNotNull(testProduct1, "Product 1 must be created from primary constructor with size parameter");
        assertNotNull(testProduct2, "Product 2 must be created from secondary function without size parameter");
        assertNotNull(testProduct3, "Product 3 must be created from bundle constructor using Item list parameter");

        /*Test primary single item product functions*/
        assertEquals("Test", testProduct1.getName(), "Product 1 name must be accessible");
        assertEquals("Test - Small", testProduct1.getPrettyName(), "Product 1 pretty name must be accessible");
        assertEquals("Small", testProduct1.getSize(), "Product 1 size must be accessible");
        assertEquals(10, testProduct1.getQuantity(), "Product 1 quantity must be accessible");
        assertEquals(price, testProduct1.getPrice(), "Product 1 price must be accessible");
        assertFalse(testProduct1.isBundleOnly(), "Product 1 bundle exclusivity must be accessible");
        assertFalse(testProduct1.isActive(), "Product 1 active status must be accessible");
        assertFalse(testProduct1.isBundle(), "Product 1 should not be a bundle");
        assertEquals("Test", testProduct1.getItems(), "The only item in Product 1 is 'Test' since it is not a bundle");

        testProduct1.setBundle(true);
        testProduct1.makeBundleOnly(true);
        assertTrue(testProduct1.isBundleOnly(), "Must be able to edit bundle exclusivity status");
        assertTrue(testProduct1.isBundle(), "Must be able to edit if a product is a bundle or not");


        /*Test size-less single item product*/
        assertNull(testProduct2.getSize(), "Product 2 was made without a size, so its size should be null");


        /*Test product that is a bundle*/
        assertTrue(testProduct3.isBundle(), "Product 3 should be a bundle");
        assertFalse(testProduct3.isBundleOnly(), "Product 3 is a bundle, so it should not be a bundle exclusive item (no infinitely nesting bundles)");
        assertEquals("Item1,Item2,Item3", testProduct3.getItems(), "Product 3 should have bundle items since it is a bundle");

    }

    /*Tests Transaction creation and accessors*/
    @Test
    public void testTransaction()
    {
        Price price = new Price(11.11);
        Customer testCustomer = new Customer("Test", "Customer", "00000", "123-456-7890", "Test@Test.com");
        Product testProduct1 = new Product("Test","Small", 10, price, false, false);
        Product testProduct2 = new Product("Test2", 5, price, true, false);
        Product testProduct3 = new Product("TestBundle", "Item1,Item2,Item3", price, true);

        ArrayList<Product> testProducts = new ArrayList<Product>();
        testProducts.add(testProduct1);
        testProducts.add(testProduct2);
        testProducts.add(testProduct3);

        LocalDate checkoutDate = LocalDate.of(2023, 3, 29);
        LocalDate returnDate = LocalDate.of(2023, 4, 2);

        Transaction testTransaction = new Transaction(testCustomer, testProducts, checkoutDate, returnDate);

        assertNotNull(testTransaction, "Transaction should be created from constructor");
        assertEquals(testCustomer, testTransaction.getCustomer(), "Customer accessor method must work");
        assertEquals(testProducts, testTransaction.getProducts(), "Products accessor method must work");
        assertEquals(checkoutDate, testTransaction.getCheckout(), "Checkout date accessor method must work");
        assertEquals(returnDate, testTransaction.getExpectedReturn(), "Expected return date accessor method must work");
        assertEquals(0, testTransaction.getDiscountPercentage(), "No discount specified in constructor. Should default to 0.");
        assertEquals(33.33, testTransaction.getTotalPrice().getTotal(), "Price should be 11.11 + 11.11 + 11.11 = 33.33");

        Transaction testTransaction2 = new Transaction(testCustomer, testProducts, checkoutDate, returnDate, 7);
        assertNotNull(testTransaction2);
        assertEquals(7, testTransaction2.getDiscountPercentage(), "Discount percentage constructor must work");
    }

    @Test
    public void testTransactionRecord()
    {
        // code to generate a transaction
        Price price = new Price(11.11);
        Customer testCustomer = new Customer("Test", "Customer", "00000", "123-456-7890", "Test@Test.com");
        Product testProduct1 = new Product("Test","Small", 10, price, false, false);
        Product testProduct2 = new Product("Test2", 5, price, true, false);
        Product testProduct3 = new Product("TestBundle", "Item1,Item2,Item3", price, true);
        ArrayList<Product> testProducts = new ArrayList<Product>();
        testProducts.add(testProduct1);
        testProducts.add(testProduct2);
        testProducts.add(testProduct3);
        LocalDate checkoutDate = LocalDate.of(2023, 3, 29);
        LocalDate returnDate = LocalDate.of(2023, 4, 2);
        Transaction testTransaction = new Transaction(testCustomer, testProducts, checkoutDate, returnDate);

        LocalDateTime time = LocalDateTime.of(2023, 3, 4, 9, 5, 35);
        TransactionRecord testTR = new TransactionRecord("Pretty cool dude",testTransaction, time, (long)895);

        /*Testing TransactionRecord Constructor and basic accessor methods*/
        assertNotNull(testTR, "TransactionRecord constructor must work");
        assertEquals("Pretty cool dude", testTR.getNotes(), "Transaction notes must be accessible");
        assertEquals(testTransaction, testTR.getTransaction(), "Transaction record must be able to fetch Transaction");
        assertEquals(time, testTR.getActualReturn(), "Transaction record must be able to fetch the actual return date");
        assertEquals((long)895, testTR.getTransactionID(), "Transaction record must be able to fetch transaction ID");

        testTR.setNotes("Blurb");
        assertEquals("Blurb", testTR.getNotes(), "Must be able to modify transaction notes");

    }

    @Test
    public void testDataManager()
    {
        Price price = new Price(11.11);
        Customer testCustomer = new Customer("Test", "Customer", "00000", "123-456-7890", "Test@Test.com");
        Product testProduct1 = new Product("Test","Small", 10, price, false, false);
        Product testProduct2 = new Product("Test2", 5, price, true, false);
        Product testProduct3 = new Product("TestBundle", "Item1,Item2,Item3", price, true);
        ArrayList<Product> testProducts = new ArrayList<Product>();
        testProducts.add(testProduct1);
        testProducts.add(testProduct2);
        testProducts.add(testProduct3);
        LocalDate checkoutDate = LocalDate.of(2023, 3, 29);
        LocalDate returnDate = LocalDate.of(2023, 4, 2);
        Transaction testTransaction = new Transaction(testCustomer, testProducts, checkoutDate, returnDate);

        LocalDateTime time = LocalDateTime.of(2023, 3, 4, 9, 5, 35);
        TransactionRecord testTR = new TransactionRecord("Pretty cool dude",testTransaction, time, (long)895);

        /* Testing DataManager class*/
        DataManager.addProductToCart(testProduct1);
        DataManager.addProductToCart("Test");


    }


}
